#include <iostream>
#include <cmath>
#include <complex>
#include <Eigen/Dense>
#include <unsupported/Eigen/FFT>

//using namespace Eigen;
//using namespace std;

typedef Eigen::Matrix<float, 512, 1> Vector512f;
typedef Eigen::Matrix< std::complex<float>, 512, 1> Vector512c;

int mseq1[] = {
	1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,0,
	1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,1,0,0,1,0,0,1,1,1,1,
	0,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,0,0,0,0,
	1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,0,0,0,1,1,1,0,1,1,1,1,0,0,
	0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,
	1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,0,0,
	0,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,1,0,0,1,0,0,
	0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,
	0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,0,0,0,0,1,0,0,1,1,
	1,0,0,1,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,1,1,1,0,1,0,0,1,1,0,1,1,1,
	0,0,1,0,0,0,1,0,1,0,0,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,1,1,0,1,1,
	0,0,1,0,0,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,1,0,0,
	1,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,1,0,1,
	0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,0,
	0,1,0,1,1,0,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,0,0,0,1,1,
	0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,1,1,1,0
};
		
int mseq2[] = {
	1,0,1,0,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,0,0,
	1,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,
	1,1,0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,
	1,0,0,1,0,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,
	0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,
	1,0,0,0,1,1,1,0,1,1,0,1,0,0,0,0,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,
	0,1,1,1,0,1,0,0,1,1,0,1,0,1,0,1,0,0,1,1,0,0,0,1,1,1,1,0,1,1,0,1,
	1,0,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,1,
	0,0,0,1,0,1,1,1,1,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,1,
	0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,0,1,1,1,0,0,
	1,0,0,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,
	0,0,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,
	0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,0,1,0,1,1,1,0,0,1,0,1,
	0,1,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,0,1,0,1,
	1,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,
	1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0
};

int m_prn[512];
Vector512c m_template;
Eigen::FFT<float> m_fft;

void generate_prn(int prn_id)
{
	if(prn_id == -2)
	{	
		//Deep copy M-sequence
		for (int k = 0; k < 512; k++)
		{
			m_prn[k] = mseq1[k];
		}
	}
	else if(prn_id == -1)
	{	
		//Deep copy M-sequence
		for (int k = 0; k < 512; k++)
		{
			m_prn[k] = mseq2[k];
		}
	}
	else //if(prn_id >= 0 && prn_id < 512)
	{	
		//Generate Gold Codes by xor'ing 2 M-sequences in different phases
		for (int k = 0; k < 512-prn_id; k++)
		{
			m_prn[k] = mseq1[k] ^ mseq2[k+prn_id];
		}
		for (int k = 512-prn_id; k < 512; k++)
		{
			m_prn[k] = mseq1[k] ^ mseq2[k-512+prn_id];
		}
	}
}

Vector512c cc430_modulator(int* prnBits)
{
	Vector512f diffs;
	Vector512f iBB;
	Vector512f qBB;
	Vector512c baseBand;
	
	//Differentially encode with +/-1 values
	diffs(0) = -2*prnBits[0] + 1;
	for (int k = 1; k < 512; k++)
	{
		char diff = prnBits[k]-prnBits[k-1];
		if(diff == 0)
		{
			diffs(k) = 1;
		}
		else
		{
			diffs(k) = -1;
		}
	}
	
	//Initialize with offset between I and Q
	iBB(0) = 1;
	qBB(0) = diffs(0);
	qBB(1) = diffs(0);
	
	for(int k = 1; k < 510; k+=2)
	{
		iBB(k) = diffs(k)*iBB(k-1);
		iBB(k+1) = iBB(k);
	}
	iBB(511) = diffs(511)*iBB(510);
	
	for(int k = 2; k < 512; k+=2)
	{
		qBB(k) = diffs(k)*iBB(k-1);
		qBB(k+1) = qBB(k);
	}
	
	for(int k = 0; k < 512; k++)
	{
		baseBand(k) = iBB(k)*cos(M_PI/2*k) + 1i*qBB(k)*sin(M_PI/2*k);
	}
	
	return baseBand;
}

int main() {

	generate_prn(-2);
	
	m_template = (cc430_modulator(m_prn)).conjugate();
	
	//Using an unscaled FFT improves performance
	m_fft.SetFlag(m_fft.Unscaled);
	
	Vector512c rf;
	
	for (int k = 0; k < 512; k++)
	{
		std::complex<float> ex = std::exp((std::complex<float>)(5.3i*M_PI/512*k));
		rf[k] = std::conj(m_template[k])*ex;
	}
	
	Vector512c temp1 = rf.cwiseProduct(m_template);
	
	Vector512c temp2 = m_fft.fwd(temp1);
	
	std::cout << 1%512;
	std::cout << "\n";
	std::cout << "\n";
	std::cout << 512%512;

}
